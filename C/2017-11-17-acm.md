**判断一个数是否是守形数**

```c
#include "stdio.h"
#include "math.h"
int main(int argc, char *argv[]){
    int n,i,j,n2,temp,sum;
    while (scanf("%d",&n)!=EOF) {
        sum = i = j = 0;
        n2 = n*n;
        temp = n;
        while (temp>0) {
            sum = (n2%10)*pow(10,i)+sum;
            temp/=10;
            i++;
            n2/=10;
        }
        if(sum == n){
            printf("Yes\n");
        }
        else{
            printf("No\n");
        }
    }
}


```

**求第i次操作时灯的状态**

```c
#include "stdio.h"
int main(){
    int n,i,temp;
    while(scanf("%d",&n)!=EOF){
        temp=0;
        for(i=1;i<=n;i++){
            if(n%i==0) temp++;
        }
        printf("%d\n",(temp)%2);
    }
    return 0;
    //主要是算法的优化,
}
```


**从所给的木棍中选取需要的木棍**

```c
#include "stdio.h"
int main(){
    int n,m,a[1000][4],i,b[1000],c[1000],j,max,min,k;
    scanf("%d",&n);
    while(n>0){
        i=0;
        max=k=j=0;
        scanf("%d",&m);
        while(m>0){
            scanf("%d %d %d",&a[i][0],&a[i][1],&a[i][2]);
            i++;
            m--;
        }
        m=i;
        min=a[0][1];
        for(i=0;i<m;i++){
            if(a[i][0]>max){
                max=a[i][0];
            }
        }
        for(i=0;i<m;i++){
            if(a[i][0]==max){
                b[j]=i;
                j++;
            }
        }
        for(i=0;i<j;i++){
            if(a[b[i]][1]<min){
                min=a[b[i]][1];
            }
        }
        for(i=0;i<j;i++){
            if(a[b[i]][1]==min){
                b[k]=a[b[i]][2];
                k++;
            }
        }
        max=0;
        for(i=0;i<k;i++){
            if(max<b[i]){
                max=b[i];
            }
        }
        printf("%d\n",max);
        n--;
    }
}

```

**炸桥问题**

```c
#include "stdio.h"
int main(){
    int m,n,i,j,flag=0,a[10002][2],b[200001][3],value=0;
    while(scanf("%d %d",&n,&m)!=EOF){
        for(i=1;i<=n;i++){
            a[i][0]=0;
            a[i][1]=0;
        }
        value=0;
        flag=0;
        j=0;
        i=0;
        while(i<m){
            scanf("%d %d %d",&b[i][0],&b[i][1],&b[i][2]);
            i++;
        }
        for(i=0;i<m;i++){
            a[b[i][0]][0]++;
            a[b[i][i]][0]++;
        }
//        for(i=0;i<m;i++){
//            printf("%d %d \n",b[i][0],b[i][1]);
//        }
        for(i=1;i<=n;i++){
//            if(a[i][0]==0){
//                printf("-1\n");
//                break;
//            }
            if(a[i][0]==1){
                for(j=0;j<m;j++){
                    if((b[j][0]==i)||(b[j][1]==i)){
                        if(value<b[j][2]){
                            value=b[j][2];
                            flag=j;
                        }
                    }
                }
            }
        }
        if(value==0) printf("-1\n");
        else printf("%d %d",b[flag][0],b[flag][1]);
    }
    return 0;
}

```


**队伍合并**

```c
#include "stdio.h"
int main(){
    int t,n,m,i,q1,q2,sum=0;
    int a[1000002];
    scanf("%d",&t);
    while(t>0){
        sum = 0;
        scanf("%d %d",&n,&m);
        for(i=1;i<=n;i++){
            a[i]=1;
        }
        while(m>0){
            scanf("%d %d",&q1,&q2);
            a[q2]=0;
            m--;
        }
        for(i=1;i<=n;i++){
            sum+=a[i];
        }
        printf("%d\n",sum);
        t--;
    }
    
    
    return 0;
    
}

```


**困难串(!!!!)**

```c
#include<stdio.h>  
#define MAX 90  
int S[MAX];//保存第i个位置应该放哪个字符  
int n,L;  
int dfs(int cur)    //返回0表示已经得到解  
{         
    int i,j,k;  
    if(cur == n)  
    {  
        for(i=0;i<cur;i++)  
        {  
            printf("%c",'A'+S[i]);  
        }  
        printf("\n");  
        return 0;  
    }  
    for(i=0;i<L;i++)  
    {  
        int ok=1;   //判断方案是否合法  
        S[cur]=i;   //将当前位置设定为i“0==A，1==B，2==C”  
          
        for(j=1;2*j<=cur+1;j++)  //循环判断长度长度为j*2的后缀  
        {  
            int equal=1;    //判断后缀中是否有前一半是否等于后一半  
            for(k=0;k<j;k++)  
            {  
                if(S[cur-k]!=S[cur-k-j]) //只要确定了后缀j*2中有一个不相等，则可以确定前一半与后一半不相等  
                {  
                    equal=0;  
                    break;  
                }  
            }  
            if(equal)  
            {  
                ok=0;  
                break;  
            }  
        }  
        if(ok)  
        {  
            if(!dfs(cur+1)) //到这里，说明0到cur位置的困难串已经确立好了，确立下一个位置就好  
                return 0;  
        }  
    }  
    return 1;  
}  
int main()  
{  
    while(scanf("%d%d",&n,&L)!=EOF)  
    {  
        memset(S,0,sizeof(S));  
        dfs(0);  
    }  
    return 0;  
}  
```


**素数环问题(!!!!)**

```c
#include<stdio.h>
#include <math.h>
int a[100];
int b[100];//当前数字是否被用过
int n;
int prime(int m){
    int i;
    for(i=2;i<=m/2;i++){
        if(m%i==0) return 0;
    }
    return 1;
}

void dfs(int t){
    int i;
    if(t==n && prime(a[0]+a[n-1]) && a[n-1]!=0){
        for(i=0;i<n;i++){
            if((i)==(n-1)) printf("%d",a[i]);
            else printf("%d ",a[i]);
        }
        printf("\n");
        return;
    }
    else {
        for(i=2;i<=n;i++){
            if(b[i-1]==0){
                a[t]=i;
                b[i-1]=1;
                if(prime(a[t]+a[t-1]))
                    dfs(t+1);
                b[i-1]=0;
            }
        }
    }
}
int main(){
    int i;
    scanf("%d",&n);
    if(n%2==1){
        printf("\n");
        return 0;
    }
    for(i=0;i<n;i++){
        a[i]=0;
        b[i]=0;
    }
    a[0]=1;
    b[0]=1;
    dfs(1);
    return 0;
}
```


**判断两直线是否会相交,给出四个点**

```c
#include <stdio.h>
#include <string.h>
int main()
{
    int x1,y1,x2,y2,x3,y3,x4,y4;
    while (scanf("%d%d%d%d",&x1,&y1,&x2,&y2)!=EOF)
    {
        scanf("%d%d%d%d",&x3,&y3,&x4,&y4);
        
        int d1=(y2-y1)*(x4-x3);//判断两条直线斜率是否相等，和斜率不存在时判断两直线是否平行
        int d2=(y4-y3)*(x2-x1);
        
        int d3=(y3-y1)*(x2-x1);//判断两条直线是否重合
        int d4=(x3-x1)*(y2-y1);
        if (d1 == d2&&d3 !=d4)
            printf("No\n");
        else printf("Yes\n");
    }
    return 0;
}

```

**判断一个字符串在另一个字符串中出现的次数(!!)**

```c
#include "stdio.h"
#include "string.h"
int main(){
    char a[30],b[30],*p1,*p2;
    int flag=1,count=0;
    scanf("%s %s",a,b);
    p1=a;p2=b; //goo o
    while(*p1!='\0'){
        if(*p1==*p2){
            p1++;p2++;
            if(*p2=='\0'){
                count++;
                p2=b;
            }
        }
        else {
            p1++;
        }
    }
    printf("%d\n",count);
    return 0;
}

```

**大数相加(长度小于四百,含有小数)(!!!!)**

```c
#include "stdio.h"
#include "string.h"
int main()
{
    int i,j,k,l,len1,len2,flag,sum[1100],p,zb,flag2;
    char a[400],b[400];
    while(scanf("%s %s",a,b)!=EOF)
    {
        if(strlen(a)==1&&strlen(b)==1&&a[0]=='0'&&b[0]=='0'){
            printf("0\n");
            continue;
        }
        if(strlen(a)==1&&a[0]=='0'){
            puts(b);
            continue;
        }
        if(strlen(b)==1&&b[0]=='0'){
            puts(a);
            continue;
        }
        flag2=1;
        len1=(int)strlen(a);len2=(int)strlen(b);
        memset(sum,0,sizeof(sum));
        flag=0;
        for(i=0;a[i];i++)
            if(a[i]=='.')
                break;
        k=i+1; //////0~~~i-1wei zhengshu
        if(a[i])
            flag=1; ///1 zhengshu 0 xiaoshu
        for(j=0;b[j];j++)
            if(b[j]=='.')
                break;
        l=j+1; /////0~~~~j-1 wei zhengshu
        if(b[j])
            flag=1;
        if(i>j)
            zb=i+1; ///zui da you zb wei zhengshu
        else
            zb=j+1;
        p=zb;      //// p wei zheng shu
        i--;
        j--;
        for(;;i--,j--)
        {
            if(i>=0&&j>=0)
                sum[p--]=a[i]-'0'+b[j]-'0';       ////sum[0] liu gei jinwei
            else if(i>=0&&j<0)
                sum[p--]=a[i]-'0';
            else if(i<0&&j>=0)
                sum[p--]=b[j]-'0';
            else if(i<0&&j<0)
                break;
        }
        p=zb+1;        //// p liu gei xiaoshudian
        for(;;k++,l++)
        {
            if(k<len1&&l<len2)
                sum[p++]=a[k]-'0'+b[l]-'0';    ///xiaoshu bufen jisuan
            else if(k<len1&&l>=len2)
                sum[p++]=a[k]-'0';
            else if(k>=len1&&l<len2)
                sum[p++]=b[l]-'0';
            else if(k>=len1&&l>=len2)
                break;
        }
        for(i=p-1;i>=0;i--)
            if(sum[i]>=10)
            {
                sum[i]=sum[i]-10;
                sum[i-1]++;
            }
        i=0;
        while(sum[i]==0)
            i++;
        for(;i<=zb;i++){
            flag2=0;
            printf("%d",sum[i]);
        }
        if(flag2==1){
            printf("0");
        }
        p--;
        while(sum[p]==0&&p>=0)
            p--;
        if(p<=zb)
            flag=0;
        if(flag)
        {
            printf(".");
            for(i=zb+1;i<=p;i++)
                printf("%d",sum[i]);
        }
        printf("\n");
    }
    return 0;
}


```

**手动字符串比较**

```c
#include "stdio.h"
#include "string.h"
int strcm(char *p1,char *p2);
int main(){
    char a[150],b[150];
    int n;
    scanf("%d",&n);
    while(n>0){
        scanf("%s %s",a,b);
        printf("%d\n",strcm(a, b));
        n--;
    }
    return 0;
}

int strcm(char *p1,char *p2){
    unsigned long l1,l2,min,i;
    l1=strlen(p1);
    l2=strlen(p2);
    if(l1==l2){
        for(i=0;i<l1;i++){
            if(*p1!=(*p2)){
                return *p1-*p2;
            }
            p1++;
            p2++;
        }
        return 0;
    }
    if(l1>l2) min=l2;
    else min = l1;
    for(i=0;i<min;i++){
        if(*p1!=(*p2)){
            return *p1-*p2;
        }
        p1++;
        p2++;
    }
    if(l1>l2) return 1;
    else return -1;
}

```

**(!!!!)有n个人(n<=1000)，用1,2,...,n编号，顺序排列，并首尾相连围成一圈。从第一个人开始报数(从1到4凡报到4的人退出圈子，且后面的人继续报数（同样从1到4报数），问最后留下的是原来第几号的那一位(用指针实**

```c
/*
用链表实现;
 */
#include "stdio.h"
#include "stdlib.h"
typedef struct Node{
    int num;
    struct Node *next;
}Lnode;
int main(){
    int n,i;
    Lnode *head,*tail,*p,*temp;
    head = (Lnode*)malloc(sizeof(Lnode));
    head->next=NULL;
    tail=head;
    scanf("%d",&n);
    for(i=0;i<n;i++){
        if(head->next==NULL){
            p=(Lnode*)malloc(sizeof(Lnode));
            p->num=1;
            p->next=NULL;
            head->next=p;//1 2
            tail=p;
        }
        else{
            p=(Lnode*)malloc(sizeof(Lnode));
            p->num=(i+1);
            p->next=NULL;
            tail->next=p;
            tail=p;
        }
    }
    tail->next=head->next; //1 2 3 4 5 tem p p-next p-next2
    p=head->next;
    temp=head;
    for(i=1;i<(n-1)*4;i++){
        temp=temp->next;
        p=p->next;
        if((i+1)%4==0){
            //printf("delete %d\n",p->num);
            temp->next=p->next;
            p=p->next;
            i++;
        }
    }
    printf("%d\n",p->num);
    return 0;
}
```

**根据输入的单词从字典中查找能组成的单词(!!!)**

```c
#include "stdio.h"
#include "string.h"
void sort(char s[]);
void sortString(char (*s)[30],int k);
int main(){
    char d[100][100],w[50],tem[100][100],ch,tem2[50],flag=1,same[100][30];
    int i1=0,j1=0,i=0,k;
    while ((ch = getchar())!='\n') {
        if(ch!=' '){
            d[i1][j1]=ch;
            j1++;
        }
        else{
            d[i1][j1]='\0';
            i1++;
            j1=0;
        }
    }
    d[i1][j1]='\0';
    gets(d[99]);
    for(i=0;i<=i1;i++){
        strcpy(tem[i], d[i]);
    }
    for(i=0;i<=i1;i++){
        sort(tem[i]);
    }
    while(scanf("%s",w)!=EOF){
        flag=1;
        strcpy(tem2, w);
        sort(tem2);
        k=0;
        for(i=0;i<=i1;i++){
            if(strcmp(tem2, tem[i])==0){
                flag=0;
                strcpy(same[k], d[i]);
                //printf("%s  ",same[k]);
                k++;
            }
        }
        sortString(same, k);
        for(i=0;i<k;i++){
            if(i==k-1) {
                printf("%s",same[i]);
                break;
            }
            else printf("%s ",same[i]);
        }
        if(flag==1) printf(":(\n");
        else printf("\n");
    }
    return 0;
}

void sortString(char (*s)[30],int k){
    int i,j;
    char temp[100];
    for(i=0;i<k-1;i++){
        for(j=0;j<k-1-i;j++){
            if(strcmp(s[j], s[j+1])>0){
                strcpy(temp, s[j]);
                strcpy(s[j], s[j+1]);
                strcpy(s[j+1], temp);
            }
        }
    }
}


void sort(char s[]){
    int i,j;
    char temp;
    for(i=0;i<strlen(s)-1;i++){
        for(j=0;j<strlen(s)-1-i;j++){
            if(s[j]>s[j+1]){
                temp = s[j];
                s[j]=s[j+1];
                s[j+1] = temp;
            }
        }
    }
}

```


**阶乘的素因数分解(!!!!)**

```c
#include "stdio.h"
int isPrime(int x);
int main(){
    int prime[100],p[100],n,i=0,j=0,temp;
    scanf("%d",&n);
    for(i=2;i<100;i++){
        if(isPrime(i)){
            prime[j]=i;
            j++;
        }
    }
    for(i=0;i<100;i++){
        if(prime[i]>n) break;
        p[i]=0;
        for(j=2;j<=n;j++){
            if(j%prime[i]==0){
                temp = j;
                //printf("%d\n",prime[i]);
                while(temp>1&&temp%prime[i]==0){
                    temp/=prime[i];
                    p[i]++;
                }
            }
        }
    }
    for(j=0;j<i;j++){
        printf(" %d",p[j]);
    }
    printf("\n");
    return 0;
}


int isPrime(int x){
    int i;
    for(i=2;i*i<=x;i++){
        if(x%i==0) return 0;
    }
    return 1;
}

```


**0068与敌人emili的斗智斗勇**

```c
/*
先找到与Emili角速度相同的同心圆,再比较(R-r)/v1和PI*R/v2的大小
 */
#include <stdio.h>
#define PI 3.1415926
int main()
{
    double R, v1, v2, r;
    while(scanf("%lf%lf%lf", &R, &v1, &v2)!=EOF)
    {
        r = R * v1 / v2;
        printf((R - r) / v1 < PI * R / v2 ? "Yes\n" : "No\n");
    }
    return 0;
}

```

**判断一个多边形是凹多边形还是凸多边形**

```c
#include "stdio.h"
int n,x[1005],y[1005];
int flag;
int judge()
{
    flag=0;
    for(int i=2;i<=n+1;i++)
    {
        int ans =(x[i]-x[i-2])*(y[i-1]-y[i-2])-(x[i-1]-x[i-2])*(y[i]-y[i-2]);
        // 0 0 1 0 1 1 0 1
        if(ans>0)
        {
            flag=1;
            break;
        }
    }
    if(flag==1)
        return 1;
    return 0;
}
int main()
{
    
    while(scanf("%d",&n))
    {
        if(n==0)
            break;
        for(int i=0;i<n;i++)
        {
            scanf("%d %d",&x[i],&y[i]);
        }
        x[n]=x[0];
        y[n]=y[0];
        x[n+1]=x[1];
        y[n+1]=y[1];
        if(judge())
            printf("concave\n");
        else
            printf("convex\n");
    }
}

```


**矩阵的相乘**

```c
#include "stdio.h"
void Multi(int a[][3],int b[][2],int c[][2]);
int main(){
    int a[2][3],b[3][2],c[2][2];
    int i,j;
    for(i=0;i<2;i++){
        for(j=0;j<3;j++){
            scanf("%d",&a[i][j]);
        }
    }
    getchar();
    for(i=0;i<3;i++){
        for(j=0;j<2;j++){
            scanf("%d",&b[i][j]);
        }
    }
    Multi(a, b, c);//13 13
    printf("%d %d\n%d %d\n",c[0][0],c[0][1],c[1][0],c[1][1]);
    return 0;
}
void Multi(int a[][3],int b[][2],int c[][2]){
    c[0][0]=a[0][0]*b[0][0]+a[0][1]*b[1][0]+a[0][2]*b[2][0];
    c[0][1]=a[0][0]*b[0][1]+a[0][1]*b[1][1]+a[0][2]*b[2][1];
    c[1][0]=a[1][0]*b[0][0]+a[1][1]*b[1][0]+a[1][2]*b[2][0];
    c[1][1]=a[1][0]*b[0][1]+a[1][1]*b[1][1]+a[1][2]*b[2][1];
}
```

**指针的应用**

```c
#include "stdio.h"
#include "stdlib.h"
void Prime(int n, int m, int *num);
int main(){
    int n,m,num[1000],i,k;
    scanf("%d %d",&n,&m);
    Prime(n, m, num);
    k=num[0];
    //printf("%d\n",k);
    for(i=1;i<=k;i++){
        printf("%d\n",num[i]);
    }
    return 0;
}

void Prime(int n,int m,int *num){
    int i,j=2,flag=1,k=1;
    for(i=n;i<=m;i++){
        flag=1;
        if(i==1) continue;
        if(i==2) {
            num[k] = i;
            k++;
            continue;
        }
        for(j=2;j<=i/2;j++){
            if(i%j==0){
                flag = 0;
                break;
            }
        }
        if(flag==1) {
            num[k]=i;
            k++;
        }
    }
    k--;
    num[0]=k;
}

```

```c
#include "stdio.h"
void Num(int num[]);
int main(){
    int num[12],a,n,i;
    for(i=0;i<10;i++){
        scanf("%d",&num[i]);
    }
    //printf("%d\n",num[0]);
    Num(num);
    a=num[10];
    n = num[11];
    printf("%d\n%d\n",a,n);
    return 0;
}

void Num(int num[]){
    int a[10][2],i,k=0,j=0,flag=1,test;
    for(i=0;i<10;i++){
        a[i][0]=-1;
        a[i][1]=-1;
    }
    for(i=0;i<10;i++){
        flag=1;
        for(k=0;k<=j;k++){
            if(a[k][0]==num[i]){
                a[k][1]++;
                flag=0;
            }
        }
        if(flag==1){
            a[j][0]=num[i];
            a[j][1]=1;
            j++;
        }
        
    }
//    for(test=0;test<=j-1;test++){
//        printf("%d  %d\n",a[test][0],a[test][1]);
//    }
    j--;
    k=a[0][1];
    //printf("%d\n",k);
    test=a[0][0];
    for(i=0;i<=j;i++){
        if(a[i][1]>k){
            k= a[i][1];
            test = a[i][0];
        }
    }
    num[10]=test;
    num[11] = k;
    
    
}

```

```c
#include "stdio.h"
void sort(int num[]);

int main(){
    int num[10],i;
    for(i=0;i<10;i++){
        scanf("%d",&num[i]);
    }
    sort(num);
    for(i=0;i<10;i++){
        printf("%d\n",num[i]);
    }
    
    return 0;
}

void sort(int num[]){
    int i,j,temp;
    for(i=0;i<9;i++){
        for(j=0;j<9-i;j++){
            if(num[j]<num[j+1]){
                temp = num[j];
                num[j]=num[j+1];
                num[j+1] = temp;
            }
        }
    }
}

```
```c
#include "stdio.h"
int Input(int s[]);
void statistics(int n, int s[], int *max, int *min, float *avg);

int main(){
    int s[1000],n,max,min;
    float avg;
    n = Input(s);
    //printf("%d\n",n);
    statistics(n, s, &max, &min, &avg);
    printf("Num=%d\nMax=%d\nMin=%d\nAvg=%.3f\n",n,max,min,avg);
    return 0;
}

int Input(int s[]){
    int i = 0,x;
    while((void)(scanf("%d",&x)),x!=0){
        s[i] = x;
        i++;
    }
    return i;
}

void statistics(int n, int s[], int *max, int *min, float *avg){
    int i;
    float sum=0;
    *max=*min=s[0];
    for(i=0;i<n;i++){
        sum+=s[i];
        if(s[i]>*max) *max=s[i];
        if(s[i]<*min) *min = s[i];
    }
    *avg=sum/n;
}
```

**彩球下落游戏.每组数据第一行为N（1<=N<=12），代表障碍物有N行。第二行N+1个整数，每个数不大于100，用空格分隔，代表最底层每个容器的分数值。第三行为一个整数，代表需要计算得到的分数**

:grinning:

```c
#include "stdio.h"
int main(){
    int n,a[13][13],i,j,grades[14];
    double result;
    while(scanf("%d",&n)!=EOF){
        for(i = 0;i<=n;i++){
            scanf("%d",&grades[i]);
        }

    }
    return 0;
}

```

**判断一个十进制数的二~十进制形式是不是回文数(!!)**
:smile:

```c
#include "stdio.h"
int trans(int x,int w);
int reverse(int x);
int main(){
    int num,flag,i,temp;
    while(scanf("%d",&num)!=EOF){
        flag=0;
        for(i=2;i<=9;i++){
            temp = trans(num,i);
            //printf("%d  ",temp);
            if(temp == reverse(temp)) flag=1;
        }
        if(reverse(num)==num) flag=1;
        if(flag==1) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}

int trans(int num,int w){
    int i,j,sum = 1;
    int a[100];
    i = 0;
    if(num==0) return 0;
    while (num>0) {   //5 101  8
        a[i] = num%w;  //
        i++;
        num=num/w;
    }
    sum = a[i-1];   //j=
    for(j = i-2;j>=0;j--){
        sum=sum*10+a[j];
    }
    return sum;
}

int reverse(int x){
    int sum;
    sum=x%10;
    while (x>=10) {
        x/=10;
        sum=sum*10+x%10;
    }
    return sum;
}

```

**把数字转换成汉字的数字,如 101 一百零一,10 十**

```c
#include "stdio.h"
#include "string.h"
void format(int i, int num,int flag,int front);
int reverse(int x,char a[]);
int main(){
    int num,j,temp,flag;
    char a[100];
    while (scanf("%d",&num) !=EOF) {    //10
        j = reverse(num, a);
        //printf("%c\n",a[1]);
        flag=1;
        while(j>=0){   //1001
            if(j==2) {
                if(a[j]-48==0&&a[j-1]-48==0&&a[j-2]-48==0){
                    break;
                }
            }
            if(j==1){
                if(a[j]-48==0&&a[j-1]-48==0){
                    break;
                }
            }
            temp = a[j]-48;
            if(flag==1) format(j+1, temp,flag,1);
            if(flag==0) format(j+1,temp,flag,a[j+1]-48);
            j--;
            flag = 0;
        }
        printf("\n");

    }
    return 0;
}

int reverse(int x,char a[]){
    int i = 0;
    a[i] = x%10+48;
    while(x>=10){
        x/=10;
        a[++i] = x%10+48;
    }
    return i;
}


void format(int i,int num,int flag,int front){
    char nu[100]="";
    if(front==0&&num==0){
        return;
    }
    switch (num) {
        case 0:
            strcpy(nu, "零\0");
            break;
        case 1:
            strcpy(nu, "一\0");
            break;
        case 2:
            strcpy(nu, "二\0");
            break;
        case 3:
            strcpy(nu, "三\0");
            break;
        case 4:
            strcpy(nu, "四\0");
            break;
        case 5:
            strcpy(nu, "五\0");
            break;
        case 6:
            strcpy(nu, "六\0");
            break;
        case 7:
            strcpy(nu, "七\0");
            break;
        case 8:
            strcpy(nu, "八\0");
            break;
        case 9:
            strcpy(nu, "九\0");
            break;
        default:
            strcpy(nu, "\0");
            break;
    }
    switch (i) {
        case 1:
            if(num!=0) printf("%s",nu);
            if(num==0&&flag==1) printf("零");
            break;
        case 2:
            if(num!=0){
                if(flag==1&&num==1) printf("十");
                else printf("%s十",nu);
            }
            if(num ==0) printf("零");
            break;
        case 3:
            if(num==0) printf("零");
            else printf("%s百",nu);
            break;
        case 4:
            if(num==0) printf("零");
            printf("%s千",nu);
            break;
        case 5:
            if(num==0) printf("零");
            printf("%s万",nu);
            break;
        default:
            break;
    }

}

```

**十进制和二进制相互转换**

```c
#include "stdio.h"
#include "string.h"
#include "math.h"
int main(){
    char f;
    int i=0,j,num,sum=0,a[100];
    while(scanf("%c",&f)!=EOF){
        scanf("%d",&num);
        if(f=='B'){
            i = 0;
            sum = 0;
            while(num>0){
                sum+=num%10*(pow(2,i));
                i++;
                num/=10;
            }
            printf("%d\n",sum);
        }
        if(f=='D'){
            i = 0;
            while (num>0) {
                a[i] = num%2;
                i++;
                num/=2;
            }
            sum = a[i-1];
            for(j = i-2;j>=0;j--){
                sum=sum*10+a[j];
            }
            printf("%08d\n",sum);
        }
    }
    return 0;
}

```


**把一个字符串中的we全部替换为you**

```c
#include "stdio.h"
#include "string.h"
int main(){
    char str[1000],str2[1000];
    int i,j;
    while (gets(str)) {
        j=0;
        for(i=0;i<strlen(str);i++){
            if(str[i]=='w'&&str[i+1]=='e'){
                strcat(str2, "you");
                i++;
                j=j+3;
            }
            else {
                str2[j] = str[i];
                j++;
            }
        }
        str2[j] = '\0';
        puts(str2);
    }
    return 0;
}

```

**在公司与租住的房子之间有M-2个充电站，他的电动车可以骑1站或2站的路程，设第一站是租住的房子，第M站是公司，而且一开始的电池是充满的，那么他共有多少中方式可以去公司？(!!!!)**

```c
#include "stdio.h"
int ways(int m);
int main(){
    int m;
    while(scanf("%d",&m)!=EOF){
         printf("%d\n",ways(m));
    }
    return 0;
}

int ways(int m){
    if(m==1) return 0;
    else if(m==2) return 1;
    else if(m==3) return 2;
    else if(m==4) return 3;
    else if(m==5) return 5;
    else if(m==6) return 8;
    else if(m==7) return 13;
    else if(m==8) return 21;
    else if(m==9) return 34;
    else if(m==10) return 55;
    //以上这些事为了减少运行时间!!!!!
    else{
        return ways(m-1)+ways(m-2);
    }
}

```

**利用指针字符串复制**

```c
#include "stdio.h"
#include "string.h"
int main(){
    char str[100],cpy[100];
    char *p;
    int i=0,n;
    gets(str);
    scanf("%d",&n);
    if(n>strlen(str)) printf("Data error!\n");
    else{
        p = &str[n];
        while(*p !='\0'){
            cpy[i] = *p;
            i++;
            p++;
        }
        puts(cpy);
    }

    return 0;
}

```

**首先输入一个数字，表示这个数列有几个数字组成，然后回车依次输入这个数列每个数字(0-9)，输入一个数字，回车一下。输出A中长度最大的所有等值数列段的始末位置，以The longest equal number list is from打头如果没有等值数列段，则输出 No equal number list.说明：始末位置是指数组下标，即0表示第一个元素。 如果有多个同等长度的等值数列，只输出第一个等值数列的起始位置。 当在一个LIST中出现两个等长的连续串的时候，我们的答案应该是第一个等长串。**

```c
#include "stdio.h"
int main(){
    int a[50],i,length=0,n,temp,start=0 ,end=0,start1,end1;
    scanf("%d",&n);
    for(i = 0;i<n;i++){
        scanf("%d",&a[i]);
    }
    for(i = 0;i<n-1;i++){
        temp = 0;
        start1 = i;
        while(a[i+1]==a[i]){
            temp++;
            i++;
        }
        end1=i;
        if(length<temp) {
            length = temp;
            start = start1;
            end = end1;
        }
    }
    if(length == 0) printf("No equal number list.\n");
    else printf("The longest equal number list is from %d to %d.\n",start,end);
    return 0;
}

```


**四种邮票的面值。输出用这四种面值组成的邮资最大的从1开始的一个连续的区间。说明：如结果为10，则表明使用4张邮票可组合出1、2、3、4、5、6、7、8、9、10这些邮资。**

```c
#include<stdio.h>
int main(){
    int i, j, k, p, a1, a2, a3, a4, m=1, flag=0;
    scanf("%d%d%d%d",&a1,&a2,&a3,&a4);
A: for( i = 0 ; i <= 5 ; i++ ){
    for( j = 0 ; j <= 5 - i ; j++ ){
        for( k = 0 ; k <= 5 - i - j ; k++ ){
            for( p = 0 ; p <= 5 - i - j - k ; p++ ){
                flag = 1 ;
                if( a1 * p + a2 * k + a3 * j + a4 * i == m ){
                    flag = 0;
                    m++;
                    goto A;
                }
            }
        }
    }
}
    printf("%d.\n",m-1);
    return 0;
}

```



**把6个互不相等的正整数a、b、c、d、e、f分成两组，若这两个数组具有以下两个相等特性:  a+b+c=d+e+f=s 且 a^2+b^2+c^2=d^2+e^2+f^2=s2，人们把这类数组(a,b,c)与(d,e,f)称为神秘3元数组。设计程序求出给定s的所有神秘3元数组（约定a<b<c, d<e<f, a<d）。例如，(1,5,6)与(2,3,7)就是s=12的神秘3元数组：1+5+6=2+3+7=12；1^2+5^2+6^2=2^2+3^2+7^2=62。**

```c
#include "stdio.h"

int main(void){
    int a,b,c,d,e,f,s;
    scanf("%d",&s);
    for(a = 1;a<=s-2*a-3;a++){    //a+1 a+2 a+3
        for(b = a+1;b<=s-2*a-1;b++){
            for(c = b+1;c<=s-a-b;c++){
                c = s-a-b;
//                printf("%d %d %d\n",a,b,c);
                for(d = a+1;d<=s-2*a-5;d++){
                    for(e=d+1;e<=s-2*d-2;e++){
                        for(f=e+1;f<=s-e-d;f++){
                            f = s - d-e;
                            if((a*a+b*b+c*c)==(d*d+e*e+f*f)) printf("(%d,%d,%d):(%d,%d,%d)\n",a,b,c,d,e,f);
                        }

                    }
                }
            }
            M
        }
    }
    return 0;
}


```


**给你2n张牌，编号为1,2,3,...,n,n+1,...,2n，这也是最初的牌的顺序。一次洗牌是把序列变为 n+1,  1,  n+2,  2,  ..,2n,n。可以证明，对于任意正整数n，都可以在经过m次这样的洗牌后，这幅牌重新回到初始的顺序。编程对于2n(n从键盘输入)张牌进行洗牌，求出重新得到初始顺序的洗牌次数m的值。**

```c
#include "stdio.h"

int main(void){
    int n,sum=1,i=0,j=1,temp;
    /*  1 2 3 4   3 1 4 2
     b[1] =a[n+1] b[2] = a[1] b[3] = a[n+2]
    */
    int a[1000],b[1000];
    scanf("%d",&n);
    temp = n;
    for(i = 1;i<=2*n;i++) a[i] = i; //1 2
    for(i = 1;i<=2*n;i++){
        if(i%2!=0) b[i] = a[++temp];  //2 1
        else b[i] = a[j++];
    }
//    printf("%d\n",b[1]);
    while(1){
        temp = n;
        j = 1;
        for(i = 1;i<=2*n;i++){
            if(i%2!=0) a[i] = b[++temp];  //1 n+1 2 1 3 n+2
            else a[i] = b[j++];  // 1 2
        }
        sum++;
        temp = n;
        j = 1;
//        printf("经%d次洗牌回到初始状态\n",a[1]);
        if(a[1] ==1) {
            printf("经%d次洗牌回到初始状态\n",sum);
            break;
        }
        for(i = 1;i<=2*n;i++){
            if(i%2!=0) b[i] = a[++temp];  //1 n+1 2 1 3 n+2
            else b[i] = a[j++];
        }
        sum++;
        if(b[1] ==1) {
            printf("经%d次洗牌回到初始状态\n",sum);
            break;
        }
    }
    return 0;
}


```

**判断密码强度等级**

```c
#include "stdio.h"
#include "string.h"
int main(void){
    char pw[20],p1=0,p2=0,p3=0,p4=0; //p1小写字母p2大写字母p3数字p4其他字符
    int n,i;
    scanf("%d",&n);
    getchar();
    while(n>0){
        p1 = p2 = p3 = p4 = 0;
        n--;
        gets(pw);

        if(strlen(pw)<6) {
            printf("Not Safe\n");
            continue;
        }
        for(i = 0;i<strlen(pw);i++){
            if(pw[i]>='a'&&pw[i]<='z') {
                p1++;
                continue;
            }
            if(pw[i]>='A'&&pw[i]<='Z') {
                p2++;
                continue;
            }
            if(pw[i]>='0'&&pw[i]<='9') {
                p3++;
                continue;
            }
            else p4++;
        }
        if(p1>0) p1 = 1;
        if(p2>0) p2 = 1;
        if(p3>0) p3 = 1;
        if(p4>0) p4 = 1;
//        printf("%d %d %d %d\n",p1,p2,p3,p4);
        if((p1+p2+p3+p4)==1) printf("Not Safe\n");
        if((p1+p2+p3+p4)==2) printf("Medium Safe\n");
        if((p1+p2+p3+p4)>=3) printf("Safe\n");

    }
    return 0;
}


```

**孪生素数**

```c
#include "stdio.h"

int ifprime(int x);
int main(void){
    int m,n,i;
    scanf("%d %d",&m,&n);
    for(i = m;i<=n;i++){
        if(ifprime(i)&&ifprime(i+2)&&(i+2)<=n){
            printf("%d %d",i,i+2);
            printf("\n");

        }
    }

    return 0;
}

int ifprime(int x){
    int i;
    if(x==1) return 0;
    for(i = 2;i<=x/2;i++){
        if(x%i==0) return 0;
    }
    return 1;
}

```
**字符串逆序**

```c
#include "stdio.h"
#include "string.h"
int main(){
    int i=0;   //abcdf
    char s[100],temp;
    gets(s);
    for(i = 0;i<strlen(s)/2;i++){
        temp = s[i];
        s[i] = s[strlen(s)-i-1];
        s[strlen(s)-i-1] = temp;
    }
    puts(s);
    return 0;
}

```

**找出元音**

```c
#include "stdio.h"
#include "string.h"
int main(){
    char s1[1000],s2[100];
    int i,j=0;
    gets(s1);
    for(i = 0;s1[i]!='\0';i++){
        if(s1[i]=='a'||s1[i]=='e'||s1[i]=='i'||s1[i]=='o'||s1[i] =='u'){
            s2[j] = s1[i];
            j++;
        }
    }
    s2[j] = '\0';
    puts(s2);
    return 0;
}

```


**寻找最长单词**

```c
#include "stdio.h"
#include "string.h"
int main(){
    char str[1000],s[100],temp[100];
    int length=0,i,j = 0;
    gets(str);
    for(i = 0;i<=strlen(str);i++){
        if(str[i] == ' '||str[i]=='\0') {
            s[j]='\0';
            if(length==0){
                length = (int)strlen(s);
                strcpy(temp, s);
                j = 0;
                continue;
            }
            if(strlen(s)>length) strcpy(temp, s);
            j = 0;
            continue;
        }
        s[j] = str[i];
        j++;

    }
    puts(temp);
    return 0;
}

```

**约瑟夫问题**

```c
#include <stdio.h>

int Josephus(int n, int m) {
    int i, x = 0;
    for (i = 1; i <= n; ++i) {
        x = (x + m) % i;
    }
    return x;
}

int main() {

    int n, m, s;

    scanf("%d%d%d", &n, &s, &m);

    printf("%d\n", Josephus(n, m) + s);
    return 0;
}
```


**绝对素数问题，该数以及该数的逆序都为素数**

```c
#include<stdio.h>
#include<string.h>
int prime(int x);
int reverse(int x);

int main(){
    int m,n,num,sum=0;
    scanf("%d %d",&m,&n);
    for(num = m;num<=n;num++){
        if(prime(num)&&prime(reverse(num))) {
            printf("%5d",num);
            sum++;
            if(sum%10==0) printf("\n");
        }

    }
    printf("\n");

    return 0;
}

int prime(int x){
    int i;
    for(i = 2;i<=x/2;i++){
        if(x%i == 0)  return 0;
    }
    return 1;
}

int reverse(int x){    //123
    int a;
    a = x%10;
    while(x>=10){
        x/=10;
        a= a*10+x%10;
    }
    return a;
}
```

**矩阵操作，将每一位除以该行的对角线元素**

```c
#include<stdio.h>
#include<string.h>
int main(){
    int i,j,n,m;
    float a[6][6];
    scanf("%d",&n);
    for(i = 0;i<n;i++){
        for(j = 0;j<n;j++){
            scanf("%f",&a[i][j]);
        }
    }
    for(i = 0;i<n;i++){
        m=a[i][i];
        for(j = 0;j<n;j++){
            a[i][j] = a[i][j]/m;
        }
    }
    for(i = 0;i<n;i++){
        for(j = 0;j<n;j++){
            printf("%.2f",a[i][j]);
            if(j!=(n-1)) printf(" ");
        }
        printf("\n");
    }
    return 0;
}

```

**链表解决约瑟夫问题**

```c
#include <stdio.h>
#include <stdlib.h>

/*构建结构体*/
typedef struct Node{
    int Num;
    struct Node *next;
}JoseNode, *PNode, *HNode;

/**********初始化循环单链表*********/
int JoseInit(HNode *h)
{
    if (!h)
    {
        printf("初始化链表错误！\n");
        return 0;
    }
    (*h)->next = (*h);//循环单链表
    return 1;

}

/*************单链表插入操作**********/
int JoseInsert(JoseNode *h, int pos, int x)
{
    PNode p=h,q;
    int i=1;
    if (pos == 1)/*尾插法*/
    {
        p->Num = x;
        p->next = p;
        return 1;
    }
    while(i<pos-1)
    {
        p=p->next;
        i++;
    }
    q=(PNode)malloc(sizeof(JoseNode));
    q->Num=x;
    q->next=p->next;
    p->next=q;
    return 1;
}

/*遍历*/
void TraverseList(HNode h, int M)
{
    int i = 0;
    PNode p = h;
    printf("参与的人的编号为：\n");
    while (i<M)
    {
        printf("%d\t", p->Num);
        p = p->next;
        i++;
    }
    printf("\n");
}
/**************出局函数****************/

int JoseDelete(HNode h, int M, int k)
{    int i;
    PNode p=h,q;
    while(M>1)
    {
        for(i=1;i<k-1;i++)
        {
            p=p->next;
        }

        q=p->next;
        p->next=q->next;
        printf("出局的人为：%d号\n",q->Num);
        free(q);

        p=p->next;
        M--;
    }
    printf("***************获胜者为：%d号***************",p->Num);
    return 1;
}


/***************************************/
int main()
{
    int i;//计数器
    int N;//参与的人数
    int k;//报数密码
    printf("请输入参与人数：");
    scanf("%d",&N);
    printf("请输入出局密码：");
    scanf("%d",&k);

    /**************得到头结点****************/
    HNode h = ((HNode)malloc(sizeof(JoseNode)));

    /***************初始化单链表************/
    JoseInit(&h);

    /******将编号插入到循环单链表中******/
    for (i = 1; i <=N; i++)
    {
        JoseInsert(h, i, i);
    }
    /**************遍历单链表***************/
    TraverseList(h,N);

    /***************出局函数************/
    if(k > 1)
        JoseDelete(h, N, k);
    else
    {
        for(i = 1; i < N; i++)
            printf("出局的人为：%d号\n",i);
        printf("***************获胜者为：%d号***************",N);
    }

    printf("\n");
    printf("\n");
    return 0;
}

```

**给一组数据排序，负数在左，正数在右**

```c
#include "stdio.h"
#include "string.h"
int main(){
    int a[100],b[100],i,j,n;
    while(scanf("%d",&n)!=EOF){
        j = 0;
        for(i = 0;i<n;i++){
            scanf("%d",&a[i]);
        }
        for(i = 0;i<n;i++){
            if(a[i]<=0) {
                printf("%d ",a[i]);
            }
            else{
                b[j] = a[i];
                j++;
            }
        }
        if(j==0) printf(" ");
        for(i = 0;i<j;i++){
            printf("%d",b[i]);
            if(i!=j-1) printf(" ");
        }
        printf("\n");
    }
    return 0;
}

#include<stdio.h>
#include<string.h>
int main(){
    int a[100],n,i,j,m,temp;
    scanf("%d",&n);
    for(i = 0;i<n;i++){
        scanf("%d",&a[i]);
    }
    for(i = 0;i<n;i++){  //-1 -2 2 4 -3     -1
        if(a[i]<0){        // 3  3
            if(i==0) continue;
            temp = a[i];
            for(m = 0;m<i;m++){
                if(a[m]>0){
                    break;
                }
            }
            if(m ==i) continue;
            for(j=i;j>m;j--){
                a[j] = a[j-1];
            }
            a[m] = temp;
        }
    }
    for(i = 0;i<n;i++){
        printf("%d",a[i]);
        if(i!=n-1) printf(" ");
    }
    printf("\n");
    return 0;
}

```


**递归求组合函数**

```c
#include<stdio.h>
#include<string.h>
int zh(int m,int n);
int main(){
    int m,n;
    scanf("%d %d",&m,&n);
    printf("%d\n",zh(m,n));
    return 0;
}

int zh(int m,int n){
    int sum=0;
    if(m<n) return 0;
    if(n == 0) {
        sum = 1;
        return sum;
    }
    if(n == 1) {
        sum +=m;
        return sum;
    }
    else{
        sum +=zh(m-1, n-1)+zh(m-1,n);
    }
    return sum;
}

```


**输入一个长度不超过 100 的字符串，删除串中的重复字符。**

```c
#include<stdio.h>
#include<string.h>
int main() {
    char str[100],str2[100];
    int i,j=0,m,flag;
    gets(str);
    for(i = 0;i<strlen(str);i++){
        if(j==0) {
            str2[j] = str[i];
            j++;
        }
        else{
            flag=1;
            for(m=0;m<=j;m++){
                if(str[i]==str2[m]) {
                    flag=0;
                    break;
                }
            }
            if(flag) {
                str2[j] = str[i];
                j++;
            }
        }
    }
    str2[j]='\0';
    puts(str2);
    return 0;
}
```







**输入数据有多组。每组输入的第一行是一个整数 n（0 < n <= 1000），表示接下来会有 n 个文件名。接下来的 n行为文件名，每个文件名占一行。文件名最多 16 个字符，并且中间不包含空格。如果 n 等于 0，则程序结束。输出以字典顺序输出每一组数据中的病毒文件名。每个文件名输出一行。**

```c
#include<stdio.h>
#include<string.h>
int isVirus(char *s)
{
    int len;
    len=(int)strlen(s);
    if(len>4 && strcmp(s+len-4,".exe") == 0) {return 1;}
    return 0;
}
int main()
{
    int n,i,j,k,l,m,flag;
    char s[1000][17],str[1000][17],temp[17];
    char *p,*q;
    scanf("%d",&n);
    while(n!=0)
    {
        j=0;
        for(i=0;i<n;i++) {scanf("%s",s[i]);}
        for(i=0;i<n;i++)
        {
            if(isVirus(s[i]))
            {
                for(k=0;k<n;k++)
                {
                    if(k==i) {continue;}
                    else
                    {
                        if((strlen(s[i])-strlen(s[k]))==4)
                        {
                            p=s[k];q=s[i];
                            flag=1;
                            while(*p!='\0' && *q!='\0')
                            {
                                if(*p==*q) {p++;q++;}
                                else {flag=0;break;}
                            }
                            if(flag) {strcpy(str[j],s[i]);j++;}
                        }
                    }
                }
            }
        }
        for(i=0;i<j;i++)
        {
            for(l=i+1;l<j;l++)
            {
                if(strcmp(str[i],str[l])>0)
                {
                    strcpy(temp,str[l]);
                    strcpy(str[l],str[i]);
                    strcpy(str[i],temp);
                }
            }
        }
        for(i=0;i<j;i++) {puts(str[i]);}
        scanf("%d",&n);
    }
    return 0;
}




```

```c
#include<stdio.h>
#include<string.h>
int main()
{
    char s1[100], s2[100],s3[50];
    int i, j, k1, k2, max=0, w1[100],w2[100],f;
    while((gets(s1)!= NULL)&&(gets(s2)!=NULL)){
        i = j = k1 = k2 = max=f=0;
        s3[0] = '\0';
        for(i=0, k1=0, f=1 ; s1[i]!='\0'; i++)
        {
            if(s1[i]==' ')  { s1[i]='\0'; f=1;}
            if(f==1&&s1[i]!='\0') { w1[k1]=i;k1++; f=0;}
        }
        for(i=0, k2=0, f=1;  s2[i]!='\0'; i++)
        {
            if(s2[i]==' ')   { s2[i]='\0';  f=1;}
            if(f==1&&s2[i]!='\0') {w2[k2]=i; k2++; f=0;}
        }
        for(i=0; i<k1; i++)
            for(j=0; j<k2; j++)
                if(strcmp(s1+w1[i],s2+w2[j])==0)
                    if(strlen(s1+w1[i])>=max)
                    {max = (int)strlen(s1+w1[i]); strcpy(s3, s1+w1[i]);}
        if(max!=0) puts(s3);
        else printf("No common word!\n");
    }


}
```
**寻找最长公共单词**

```c
错误代码
#include "stdio.h"
#include "string.h"

int main(){
    char str1[100], str2[100],s1[20],length=0,s2[20],result[20];
    int i,j=0,k=0;
    fgets(str1, 100, stdin);
    fgets(str2, 100, stdin);
    for(i = 0;i<strlen(str1)-1;i++){
        if(str1[i]!='?'&&str1[i]!=','&&str1[i]!='.') {
            s1[j] = str1[i];
            j++;
        }
        else{
            s1[j]='\0';
            puts(s1);
            for(j = 0;j<strlen(str2)-1;j++){
                if(!(str2[i]=='?'||str2[i]==','||str2[i]=='.')) {
                    s2[k] = str2[j];
                    k++;
                }
                else{
                    s2[k]='\0';
                    //                    puts(str2);
                    if(strcmp(s1, s2)==0&&strlen(s1)>length) {
                        length=strlen(s1);
                        strcpy(result, s2);
                    }
                    k=0;
                }
            }
            j=0;

        }
    }
    if(length!=0) printf("%s\n",result);
    else printf("No common word!\n");
    return 0;
}
```










```c
#include "stdio.h"
#include "string.h"
int main(){
    char str1[50][20];
    char str2[50][20];
    int stus, comes,i,j=0;
    while(scanf("%d %d",&stus,&comes)!=EOF){
        j=0;
        for(i=0;i<stus;i++){
            scanf("%s",str1[i]);
        }
        for(i = 0;i<comes;i++){
            scanf("%s",str2[i]);
        }
        for(i=0;i<stus;i++){
            if(strcmp(str1[i], str2[j])==0){
                printf("Yes\n");
                j++;
            }
            else{
                printf("No\n");
            }
        }
    }
    return 0;
}
```






**(!!!!)**

```c
#include<stdio.h>
int main(){
    int a,b,c,d,e,f;//a-f对应1*1到6*6的箱子
    int u[]={0,5,3,1};//装3*3类箱子不满时可以装2*2类箱子的4种情形
    while(scanf("%d%d%d%d%d%d", &a, &b, &c, &d, &e, &f)!=EOF){
        if(a==0 && b==0 && c==0 && d==0 && e==0 && f==0)break;
        int x,y;//x代表用于装2*2类箱子的空位，y代表用于装1类箱子的空位
        int N=0;//总共所需要的包装的数量
        N=f+e+d+(c+3)/4;//统计3*3-6*6类箱子所需要的包装数
        //上式中（c+3)/4的作用：当c/4的余数不论为几时，都需要再增加一个箱子，即只能多不能少；
        x=5*d+u[c%4];//统计4类箱子和3类箱子留给2类箱子的空位
        if(b >x){
            N+=(b-x+8)/9;//统计算上遗留空位2*2类箱子所占的包装数量
        }
        y=N*36-f*36-e*25-d*16-c*9-b*4;//遗留给1*1类箱子的空位
        if(a >y){
            N+=(a-y+35)/36;
        }
        printf("%d\n", N);
    }
    return 0;
}


#include "stdio.h"
int main(void){
    char str[100], ch;
    int i=0;
    scanf("%s",str);
    getchar();
    scanf("%c",&ch);
    while(str[i] != '\0'){
        if(str[i] == ch) {
            i++;
            continue;
        }
        printf("%c",str[i]);
        i++;
    }
    printf("\n");
    return 0;
}
```

```c
#include<stdio.h>
#include<string.h>
int main()
{
    char s1[100], s2[100],s3[50];
    int i, j, k1, k2, max=0, w1[100],w2[100],f;
    gets(s1);  gets(s2);
    for(i=0, k1=0, f=1 ; s1[i]!='\0'; i++)
    {
        if(s1[i]==' ')  { s1[i]='\0'; f=1;}
        if(f==1&&s1[i]!='\0') { w1[k1]=i;k1++; f=0;}
    }
    for(i=0, k2=0, f=1;  s2[i]!='\0'; i++)
    {
        if(s2[i]==' ')   { s2[i]='\0';  f=1;}
        if(f==1&&s2[i]!='\0') {w2[k2]=i; k2++; f=0;}
    }
    for(i=0; i<k1; i++)
        for(j=0; j<k2; j++)
            if(strcmp(s1+w1[i],s2+w2[j])==0)
                if(strlen(s1+w1[i])>=max)
                {max = (int)strlen(s1+w1[i]); strcpy(s3, s1+w1[i]);}
    puts(s3);
    return 0;
}
```


